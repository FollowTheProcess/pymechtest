{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"pymechtest \u00b6 pymechtest is a small, hopefully helpful python package to help engineers collate, process, analyse, and report on mechanical test data. I built pymechtest to help automate the things I did on a near-daily basis as a materials engineer. I hope it can prove some use to you too! Source Code : https://github.com/FollowTheProcess/pymechtest Documentation : https://FollowTheProcess.github.io/pymechtest/ What is it? \u00b6 :warning: Project under pre-release development Have you ever had to process a bunch of csv output from a mechanical test machine, copying and pasting data into a hacky Excel template to calculate things like elastic modulus and yield strength? Only to then have to make another Excel file where you create a summary table? And then have to copy and paste that into a report or an email? And then you have to plot the data in Excel and spend half an hour tweaking the colours to get it to look at least halfway professional? No more! pymechtest has a very simple goal: to reduce the amount of time engineers spend munging data after a batch of mechanical testing. Here is a quick taste of how easy it is to go from raw data to a tabular summary and a stress-strain plot: from pymechtest import Tensile # header and id_row are related to the structure of your csv files tens = Tensile ( folder = \"path/to/raw/data\" , header = 8 , id_row = 3 ) # Load all data in the folder into a pandas dataframe tens . load_all () # Plot a really nice stress-strain curve with Altair tens . plot_curves () # Show a summary table with modulus and strength for each sample tens . summarise () You'll see more about these methods in the docs later... The key features are: Intuitive : The API is very intuitive, with descriptive methods like plot_curves and summarise Column Autodetection : pymechtest will try to auto-detect which columns correspond to stress and strain, and ask you to clarify if it can't. Sensible Defaults : The API is designed around sensible defaults for things like modulus strain range, whether to expect a yield strength etc. Automatic Calculations : pymechtest will automatically calculate strength, elastic modulus, yield strength etc. for you. Elegant Looking Stress Strain Curves : pymechtest uses altair to plot amazing looking stress strain curves. Reliable : pymechtest uses battle-tested libraries like pandas , numpy and altair to do most of the work. The API is really a domain-specific convenience wrapper. pymechtest also maintains high test coverage. Installation \u00b6 pip install pymechtest I also plan to make a conda package for this, once I've learned how to do it! Help \u00b6 An important note about pymechtest While I've tried to generalise the API to be of use on different formats of raw data, it is impossible to cover every type of format and ensure compatability. One way you can help is by try it on your data format, and raise an issue or submit a PR implementing your new format!","title":"Home"},{"location":"index.html#pymechtest","text":"pymechtest is a small, hopefully helpful python package to help engineers collate, process, analyse, and report on mechanical test data. I built pymechtest to help automate the things I did on a near-daily basis as a materials engineer. I hope it can prove some use to you too! Source Code : https://github.com/FollowTheProcess/pymechtest Documentation : https://FollowTheProcess.github.io/pymechtest/","title":"pymechtest"},{"location":"index.html#what-is-it","text":":warning: Project under pre-release development Have you ever had to process a bunch of csv output from a mechanical test machine, copying and pasting data into a hacky Excel template to calculate things like elastic modulus and yield strength? Only to then have to make another Excel file where you create a summary table? And then have to copy and paste that into a report or an email? And then you have to plot the data in Excel and spend half an hour tweaking the colours to get it to look at least halfway professional? No more! pymechtest has a very simple goal: to reduce the amount of time engineers spend munging data after a batch of mechanical testing. Here is a quick taste of how easy it is to go from raw data to a tabular summary and a stress-strain plot: from pymechtest import Tensile # header and id_row are related to the structure of your csv files tens = Tensile ( folder = \"path/to/raw/data\" , header = 8 , id_row = 3 ) # Load all data in the folder into a pandas dataframe tens . load_all () # Plot a really nice stress-strain curve with Altair tens . plot_curves () # Show a summary table with modulus and strength for each sample tens . summarise () You'll see more about these methods in the docs later... The key features are: Intuitive : The API is very intuitive, with descriptive methods like plot_curves and summarise Column Autodetection : pymechtest will try to auto-detect which columns correspond to stress and strain, and ask you to clarify if it can't. Sensible Defaults : The API is designed around sensible defaults for things like modulus strain range, whether to expect a yield strength etc. Automatic Calculations : pymechtest will automatically calculate strength, elastic modulus, yield strength etc. for you. Elegant Looking Stress Strain Curves : pymechtest uses altair to plot amazing looking stress strain curves. Reliable : pymechtest uses battle-tested libraries like pandas , numpy and altair to do most of the work. The API is really a domain-specific convenience wrapper. pymechtest also maintains high test coverage.","title":"What is it?"},{"location":"index.html#installation","text":"pip install pymechtest I also plan to make a conda package for this, once I've learned how to do it!","title":"Installation"},{"location":"index.html#help","text":"An important note about pymechtest While I've tried to generalise the API to be of use on different formats of raw data, it is impossible to cover every type of format and ensure compatability. One way you can help is by try it on your data format, and raise an issue or submit a PR implementing your new format!","title":"Help"},{"location":"getting_started/options.html","text":"Options & Arguments \u00b6 All the static test classes in pymechtest have the same options and arguments available to them. These help you tweak what it does and doesn't load, what format the columns are in, whether you have specimen ID numbers in the files etc. Here we'll explain how to use these with an example. Example \u00b6 Let's use the Tensile class for a simple batch of tensile tests. Don't forget, pymechtest also has Compression and Flexure classes we could easily have used, they all work exactly the same way! pymechtest is designed to work directly from the raw data exported by the machine, so all you have to do is 'point it' at the folder where your batch of test data is and it will do the rest. In order for it work properly though, with some formats of data you might have to configure a few things. ID Row \u00b6 Let's say you've just finished doing a batch of tensile tests and have a folder of randomly named csv files corresponding to this batch. Your csv file will look something like this (when opened in Excel): There may or may not be some metadata at the top of the file, and then there'll be your data below. In this example you notice we have a row called Specimen ID with the number 9, uniquely identifying this particular specimen in the batch. Well pymechtest can use this! All you have to do is specify which row this ID is on with the id_row argument... In our example, it's on the 4th row (so 3rd row in 0-indexed python) from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 ) Just by specifying this, you get this ID integrated into the rest of your work for free. For example, now the .summarise method will show it... If your csv structure doesn't have this format, don't worry. If you don't enter anything for id_row the Specimen ID column in the .summarise result will use the file name instead. Header \u00b6 Notice again in our example file, there's a load of metadata on top (which is where we got the Specimen ID from) containing things like specimen width, thickness etc. and the actual data doesn't start until later on down the file. If you just try and read this in as it is, you'll get an error... This error actually comes from pandas not from pymechtest, and it's because pandas tries to infer the structure of a csv from the first few rows. In our example case, the first few rows are different to the actual data. The actual data begins after row 9 (so 8 in 0-indexed python) To fix this, you need to pass the header argument, telling pymechtest which row the table header row is i.e. the row containing your column titles like Tensile stress etc. In our case, this means header = 8 from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 ) And now it works perfectly! Note: In our example, the csv file had the units in brackets below the table headers. If this is true for your data too, or infact if your data has any non-numerics below your table headers, don't worry! pymechtest (well actually pandas ) is smart enough to remove these for you. Currently pymechtest doesn't support unit conversion. It assumes SI units: Stress = MPa, Modulus = GPa, Strain = %. This is something I want to support in the future and is on the roadmap. Strain1 & Strain2 \u00b6 Notice that the .summarise method calculates the elastic modulus. But you didn't tell it to do that, and you didn't specify how to calculate it or what strain range to use etc. This is because pymechtest uses sensible defaults and actually configured this behind the scenes without you knowing. The range over which the elastic modulus is calculated is controlled by the strain1 and strain2 arguments and defaults to 0.05 and 0.15 (in % strain). This is a good range for a lot of common materials. You can always override this by explicitly defining what you want strain1 and strain2 to be... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 , strain1 = 0.001 , strain2 = 0.1 ) Now pymechtest will use your values of strain1 and strain2 to calculate the modulus. \\[ E=\\Delta\\sigma / \\Delta\\epsilon \\] With your ranges: \\[ E=\\Delta\\sigma / (strain2 - strain1) \\] Obviously, if you define your own ranges, it's now up to you that those ranges are valid and you are still capturing the elastic portion of the stress strain curve, so you might want to check it out with .plot_curves() first! Currently, only Young's modulus is supported. In the future I want to provide the option for different types of modulus i.e. secant, chord etc. This is on the roadmap! Expect Yield \u00b6 You've seen how the .summarise method returns a column for yield strength in our earlier example. How did it know how to do that? Well there's an argument for that: expect_yield which defaults to True (a sensible default). If you were testing a load of carbon fibre test pieces in the fibre direction, they are elastic to failure and the concept of yield strength becomes irrelevant. In that case, you would pass expect_yield = False when instantiating the Tensile class... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 , header = 8 , expect_yield = False ) Now if you call .summarise on your non-yielding data, you won't see the yield strength column because it won't be calculated... By tweaking all these things, it's my aim that pymechtest can be used to help you process lots of different types of mechanical test data output!","title":"Options"},{"location":"getting_started/options.html#options-arguments","text":"All the static test classes in pymechtest have the same options and arguments available to them. These help you tweak what it does and doesn't load, what format the columns are in, whether you have specimen ID numbers in the files etc. Here we'll explain how to use these with an example.","title":"Options &amp; Arguments"},{"location":"getting_started/options.html#example","text":"Let's use the Tensile class for a simple batch of tensile tests. Don't forget, pymechtest also has Compression and Flexure classes we could easily have used, they all work exactly the same way! pymechtest is designed to work directly from the raw data exported by the machine, so all you have to do is 'point it' at the folder where your batch of test data is and it will do the rest. In order for it work properly though, with some formats of data you might have to configure a few things.","title":"Example"},{"location":"getting_started/options.html#id-row","text":"Let's say you've just finished doing a batch of tensile tests and have a folder of randomly named csv files corresponding to this batch. Your csv file will look something like this (when opened in Excel): There may or may not be some metadata at the top of the file, and then there'll be your data below. In this example you notice we have a row called Specimen ID with the number 9, uniquely identifying this particular specimen in the batch. Well pymechtest can use this! All you have to do is specify which row this ID is on with the id_row argument... In our example, it's on the 4th row (so 3rd row in 0-indexed python) from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 ) Just by specifying this, you get this ID integrated into the rest of your work for free. For example, now the .summarise method will show it... If your csv structure doesn't have this format, don't worry. If you don't enter anything for id_row the Specimen ID column in the .summarise result will use the file name instead.","title":"ID Row"},{"location":"getting_started/options.html#header","text":"Notice again in our example file, there's a load of metadata on top (which is where we got the Specimen ID from) containing things like specimen width, thickness etc. and the actual data doesn't start until later on down the file. If you just try and read this in as it is, you'll get an error... This error actually comes from pandas not from pymechtest, and it's because pandas tries to infer the structure of a csv from the first few rows. In our example case, the first few rows are different to the actual data. The actual data begins after row 9 (so 8 in 0-indexed python) To fix this, you need to pass the header argument, telling pymechtest which row the table header row is i.e. the row containing your column titles like Tensile stress etc. In our case, this means header = 8 from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 ) And now it works perfectly! Note: In our example, the csv file had the units in brackets below the table headers. If this is true for your data too, or infact if your data has any non-numerics below your table headers, don't worry! pymechtest (well actually pandas ) is smart enough to remove these for you. Currently pymechtest doesn't support unit conversion. It assumes SI units: Stress = MPa, Modulus = GPa, Strain = %. This is something I want to support in the future and is on the roadmap.","title":"Header"},{"location":"getting_started/options.html#strain1-strain2","text":"Notice that the .summarise method calculates the elastic modulus. But you didn't tell it to do that, and you didn't specify how to calculate it or what strain range to use etc. This is because pymechtest uses sensible defaults and actually configured this behind the scenes without you knowing. The range over which the elastic modulus is calculated is controlled by the strain1 and strain2 arguments and defaults to 0.05 and 0.15 (in % strain). This is a good range for a lot of common materials. You can always override this by explicitly defining what you want strain1 and strain2 to be... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 , strain1 = 0.001 , strain2 = 0.1 ) Now pymechtest will use your values of strain1 and strain2 to calculate the modulus. \\[ E=\\Delta\\sigma / \\Delta\\epsilon \\] With your ranges: \\[ E=\\Delta\\sigma / (strain2 - strain1) \\] Obviously, if you define your own ranges, it's now up to you that those ranges are valid and you are still capturing the elastic portion of the stress strain curve, so you might want to check it out with .plot_curves() first! Currently, only Young's modulus is supported. In the future I want to provide the option for different types of modulus i.e. secant, chord etc. This is on the roadmap!","title":"Strain1 &amp; Strain2"},{"location":"getting_started/options.html#expect-yield","text":"You've seen how the .summarise method returns a column for yield strength in our earlier example. How did it know how to do that? Well there's an argument for that: expect_yield which defaults to True (a sensible default). If you were testing a load of carbon fibre test pieces in the fibre direction, they are elastic to failure and the concept of yield strength becomes irrelevant. In that case, you would pass expect_yield = False when instantiating the Tensile class... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 , header = 8 , expect_yield = False ) Now if you call .summarise on your non-yielding data, you won't see the yield strength column because it won't be calculated... By tweaking all these things, it's my aim that pymechtest can be used to help you process lots of different types of mechanical test data output!","title":"Expect Yield"},{"location":"getting_started/usage.html","text":"First Steps \u00b6 pymechtest is a super tiny package, it focusses on just a few common tasks, as such it's super easy to learn! Installation \u00b6 The very first thing you need to do is install pymechtest : pip install pymechtest This will install pymechtest and its core dependencies. Getting Data In \u00b6 All you have to do to get data into pymechtest is instantiate the class specific to your test method (pymechtest currently supports Tensile , Flexure , and Compression static tests with some limited support for Fatigue (I'm working on it!))... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) This path can either be a simple string as in the example above, or you can pass it a pathlib.Path or infact any osPathLike object... from pymechtest import Tensile from pathlib import Path data = Path ( \"path/to/raw/data\" ) . resolve () tens = Tensile ( folder = data ) Under the hood, pymechtest converts this to a pathlib.Path anyway so it can easily glob pattern match for csv files. Now What? \u00b6 Now you have your data in, you can do a few things with it. Load to a Dataframe \u00b6 If you know pandas and want to use its comprehensive functionality to manipulate your data, you can get your entire folder of data in a single dataframe... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) df = tens . load_all () This will recursively search your folder for csv files and load them all into a dataframe for you to do whatever you want with! Summarise \u00b6 If all you really want to see are the key values like elastic modulus, tensile strength etc for each specimen in your sample, use the .summarise() method... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . summarise () This will extract key values such as elastic modulus, tensile strength, yield strength (if expect_yield = True we'll talk about this later.) for each specimen in your sample. Stress-Strain Curves \u00b6 Making nice looking stress strain curves has always been the bane of my life. With pymechtest, a gorgeous graph is only a method away.. from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . plot_curves () If you're working in a jupyter notebook or an IDE that supports them you will see the plot appear. You can also save the generated plot but we'll talk about that later too.","title":"Usage"},{"location":"getting_started/usage.html#first-steps","text":"pymechtest is a super tiny package, it focusses on just a few common tasks, as such it's super easy to learn!","title":"First Steps"},{"location":"getting_started/usage.html#installation","text":"The very first thing you need to do is install pymechtest : pip install pymechtest This will install pymechtest and its core dependencies.","title":"Installation"},{"location":"getting_started/usage.html#getting-data-in","text":"All you have to do to get data into pymechtest is instantiate the class specific to your test method (pymechtest currently supports Tensile , Flexure , and Compression static tests with some limited support for Fatigue (I'm working on it!))... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) This path can either be a simple string as in the example above, or you can pass it a pathlib.Path or infact any osPathLike object... from pymechtest import Tensile from pathlib import Path data = Path ( \"path/to/raw/data\" ) . resolve () tens = Tensile ( folder = data ) Under the hood, pymechtest converts this to a pathlib.Path anyway so it can easily glob pattern match for csv files.","title":"Getting Data In"},{"location":"getting_started/usage.html#now-what","text":"Now you have your data in, you can do a few things with it.","title":"Now What?"},{"location":"getting_started/usage.html#load-to-a-dataframe","text":"If you know pandas and want to use its comprehensive functionality to manipulate your data, you can get your entire folder of data in a single dataframe... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) df = tens . load_all () This will recursively search your folder for csv files and load them all into a dataframe for you to do whatever you want with!","title":"Load to a Dataframe"},{"location":"getting_started/usage.html#summarise","text":"If all you really want to see are the key values like elastic modulus, tensile strength etc for each specimen in your sample, use the .summarise() method... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . summarise () This will extract key values such as elastic modulus, tensile strength, yield strength (if expect_yield = True we'll talk about this later.) for each specimen in your sample.","title":"Summarise"},{"location":"getting_started/usage.html#stress-strain-curves","text":"Making nice looking stress strain curves has always been the bane of my life. With pymechtest, a gorgeous graph is only a method away.. from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . plot_curves () If you're working in a jupyter notebook or an IDE that supports them you will see the plot appear. You can also save the generated plot but we'll talk about that later too.","title":"Stress-Strain Curves"}]}