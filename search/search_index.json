{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"pymechtest \u00b6 pymechtest is a small, hopefully helpful python package to help engineers collate, process, analyse, and report on mechanical test data. I built pymechtest to help automate the things I did on a near-daily basis as a materials engineer. I hope it can prove some use to you too! Source Code : https://github.com/FollowTheProcess/pymechtest Documentation : https://FollowTheProcess.github.io/pymechtest/ What is it? \u00b6 Project under pre-release development Have you ever had to process a bunch of csv output from a mechanical test machine, copying and pasting data into a hacky Excel template to calculate things like elastic modulus and yield strength? Only to then have to make another Excel file where you create a summary table? And then have to copy and paste that into a report or an email? And then you have to plot the data in Excel and spend half an hour tweaking the colours to get it to look at least halfway professional? No more! pymechtest has a very simple goal: to reduce the amount of time engineers spend munging data after a batch of mechanical testing. Here is a quick taste of how easy it is to go from raw data to a gorgeous stress-strain plot: from pymechtest import Tensile # header and id_row are related to the structure of your csv files tens = Tensile ( folder = \"path/to/raw/data\" , header = 8 , id_row = 3 ) # Plot a really nice stress-strain curve with Altair tens . plot_curves () You'll see more about these methods in the docs later... The key features are: Intuitive : The API is very intuitive, with descriptive methods like plot_curves and summarise Column Autodetection : pymechtest will try to auto-detect which columns correspond to stress and strain, and ask you to clarify if it can't. Sensible Defaults : The API is designed around sensible defaults for things like modulus strain range, whether to expect a yield strength etc. Automatic Calculations : pymechtest will automatically calculate strength, elastic modulus, yield strength etc. for you. Elegant Looking Stress Strain Curves : pymechtest uses altair to plot amazing looking stress strain curves. Reliable : pymechtest uses battle-tested libraries like pandas , numpy and altair to do most of the work. The API is really a domain-specific convenience wrapper. pymechtest also maintains high test coverage. Installation \u00b6 pip install pymechtest I also plan to make a conda package for this, once I've learned how to do it! Help \u00b6 An important note about pymechtest While I've tried to generalise the API to be of use on different formats of raw data, it is impossible to cover every type of format and ensure compatability. One way you can help is by try it on your data format, and raise an issue or submit a PR implementing your new format!","title":"Home"},{"location":"index.html#pymechtest","text":"pymechtest is a small, hopefully helpful python package to help engineers collate, process, analyse, and report on mechanical test data. I built pymechtest to help automate the things I did on a near-daily basis as a materials engineer. I hope it can prove some use to you too! Source Code : https://github.com/FollowTheProcess/pymechtest Documentation : https://FollowTheProcess.github.io/pymechtest/","title":"pymechtest"},{"location":"index.html#what-is-it","text":"Project under pre-release development Have you ever had to process a bunch of csv output from a mechanical test machine, copying and pasting data into a hacky Excel template to calculate things like elastic modulus and yield strength? Only to then have to make another Excel file where you create a summary table? And then have to copy and paste that into a report or an email? And then you have to plot the data in Excel and spend half an hour tweaking the colours to get it to look at least halfway professional? No more! pymechtest has a very simple goal: to reduce the amount of time engineers spend munging data after a batch of mechanical testing. Here is a quick taste of how easy it is to go from raw data to a gorgeous stress-strain plot: from pymechtest import Tensile # header and id_row are related to the structure of your csv files tens = Tensile ( folder = \"path/to/raw/data\" , header = 8 , id_row = 3 ) # Plot a really nice stress-strain curve with Altair tens . plot_curves () You'll see more about these methods in the docs later... The key features are: Intuitive : The API is very intuitive, with descriptive methods like plot_curves and summarise Column Autodetection : pymechtest will try to auto-detect which columns correspond to stress and strain, and ask you to clarify if it can't. Sensible Defaults : The API is designed around sensible defaults for things like modulus strain range, whether to expect a yield strength etc. Automatic Calculations : pymechtest will automatically calculate strength, elastic modulus, yield strength etc. for you. Elegant Looking Stress Strain Curves : pymechtest uses altair to plot amazing looking stress strain curves. Reliable : pymechtest uses battle-tested libraries like pandas , numpy and altair to do most of the work. The API is really a domain-specific convenience wrapper. pymechtest also maintains high test coverage.","title":"What is it?"},{"location":"index.html#installation","text":"pip install pymechtest I also plan to make a conda package for this, once I've learned how to do it!","title":"Installation"},{"location":"index.html#help","text":"An important note about pymechtest While I've tried to generalise the API to be of use on different formats of raw data, it is impossible to cover every type of format and ensure compatability. One way you can help is by try it on your data format, and raise an issue or submit a PR implementing your new format!","title":"Help"},{"location":"api/static.html","text":"Any Static Test Class \u00b6 \u00b6 Mechanical Test Base class. Parameters: Name Type Description Default folder Union[Path, str] String or Path-like folder containing test data. required id_row int Row number of the specimen ID. Most test machines export a headed csv file with some metadata like date, test method name etc, specimen ID should be contained in this section. Defaults to 0. required stress_col str Name of the column containing stress data. If not passed, pymechtest will try to autodetect it from your data. required strain_col str Name of the column containing strain data. If not passed, pymechtest will try to autodetect it from your data. required header int 0-indexed row number of the table header (i.e. the row containing things like \"Stress\", \"Strain\", \"Load\" etc.). Defaults to 0. required strain1 float Lower strain bound for modulus calculation. Must be in %. Defaults to 0.05. required strain2 float Upper strain bound for modulus calculation. Must be in %. Defaults to 0.15. required expect_yield bool Whether the specimens are expected to be elastic to failure (False) or they are expected to have a yield strength (True). Defaults to True. required load_all ( self ) \u00b6 Loads all the found files in 'folder' into a dataframe. Recursively searches 'folder' for all csv files, grabs the specimen identifier specified during 'id_row' and includes this in the dataframe. Returns: Type Description DataFrame pd.DataFrame: All found test data with specimen identifier. Source code in pymechtest/base.py def load_all ( self ) -> pd . DataFrame : \"\"\" Loads all the found files in 'folder' into a dataframe. Recursively searches 'folder' for all csv files, grabs the specimen identifier specified during 'id_row' and includes this in the dataframe. Returns: pd.DataFrame: All found test data with specimen identifier. \"\"\" # Cast to Path so can glob even if user passed str fp = Path ( self . folder ) . resolve () df = ( ( pd . concat ([ self . _load ( f ) for f in sorted ( fp . rglob ( \"*.csv\" ))])) . assign ( spec_id = lambda x : pd . Categorical ( x [ \"Specimen ID\" ])) . drop ( columns = [ \"Specimen ID\" ]) . rename ( columns = { \"spec_id\" : \"Specimen ID\" }) ) # Reorder the columns for OCD reasons col = df . pop ( \"Specimen ID\" ) df . insert ( 0 , \"Specimen ID\" , col ) return df plot_curves ( self , title = None , save_path = None , save_method = 'selenium' , x_label = None , y_label = None , height = 500 , width = 750 ) \u00b6 Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Parameters: Name Type Description Default title Optional[str] Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". None save_path Union[str, pathlib.Path] str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. None save_method Optional[str] One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' 'selenium' x_label Optional[str] Label for x-axis. Defaults to \"{class name}Strain (%)\". None y_label Optional[str] Label for y-axis. Defaults to \"{class name}Stress (MPa)\". None height int Height of the plot. Defaults to 500. 500 width int Width of the plot. Defaults to 750. 750 Returns: Type Description Chart alt.Chart: Stress strain plot. Source code in pymechtest/base.py def plot_curves ( self , title : Optional [ str ] = None , save_path : Optional [ Union [ str , Path ]] = None , save_method : Optional [ str ] = \"selenium\" , x_label : Optional [ str ] = None , y_label : Optional [ str ] = None , height : int = 500 , width : int = 750 , ) -> alt . Chart : \"\"\" Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Args: title (str, optional): Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". save_path (Union[str, Path], optional): str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. save_method (str, optional): One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' x_label (str, optional): Label for x-axis. Defaults to \"{class name}Strain (%)\". y_label (str, optional): Label for y-axis. Defaults to \"{class name}Stress (MPa)\". height (int, optional): Height of the plot. Defaults to 500. width (int, optional): Width of the plot. Defaults to 750. Returns: alt.Chart: Stress strain plot. \"\"\" # Altair will warn if over 5,000 rows in a notebook. This is cleanest solution. alt . data_transformers . enable ( \"data_server\" ) if not x_label : x_label = f \" { self . __class__ . __qualname__ } Strain (%)\" if not y_label : y_label = f \" { self . __class__ . __qualname__ } Stress (MPa)\" if not title : title = f \" { self . __class__ . __qualname__ } Stress Strain Curves\" df = self . load_all () stress_col = self . _get_stress_col ( df ) strain_col = self . _get_strain_col ( df ) chart = ( alt . Chart ( data = df ) . mark_line ( size = 1 ) . encode ( x = alt . X ( f \" { strain_col } :Q\" , title = x_label ), y = alt . Y ( f \" { stress_col } :Q\" , title = y_label ), color = alt . Color ( \"Specimen ID:N\" , title = \"Specimen ID\" ), ) . properties ( title = title , height = height , width = width ) ) if save_method not in set ([ \"selenium\" , \"node\" ]): raise ValueError ( f \"Save method must be one of 'selenium' or 'node'. Got: { save_method } \" ) if save_path : fp = Path ( save_path ) . resolve () save ( chart , fp = str ( fp ), fmt = \"png\" , scale_factor = 6.0 , method = save_method , ) return chart stats ( self ) \u00b6 Returns a table of summary statistics e.g. mean, std, cov etc. for the data in folder. Uses pandas df.describe() to do the bulk of the work, just adds in cov for good measure. Returns: Type Description DataFrame pd.DataFrame: Summary statistics. Source code in pymechtest/base.py def stats ( self ) -> pd . DataFrame : \"\"\" Returns a table of summary statistics e.g. mean, std, cov etc. for the data in folder. Uses pandas df.describe() to do the bulk of the work, just adds in cov for good measure. Returns: pd.DataFrame: Summary statistics. \"\"\" df = self . summarise () . describe () df . loc [ \"cov%\" ] = df . loc [ \"std\" ] / df . loc [ \"mean\" ] * 100 # Reorganise so cov is close to std new_index = [ \"count\" , \"mean\" , \"std\" , \"cov%\" , \"min\" , \"25%\" , \"50%\" , \"75%\" , \"max\" ] df = df . reindex ( new_index ) return df summarise ( self ) \u00b6 High level summary method, generates a dataframe containing key test values such as UTS, Modulus etc. for all the data in the target folder. Returns: Type Description DataFrame pd.DataFrame: Dataframe containing test summary values for each specimen. Source code in pymechtest/base.py def summarise ( self ) -> pd . DataFrame : \"\"\" High level summary method, generates a dataframe containing key test values such as UTS, Modulus etc. for all the data in the target folder. Returns: pd.DataFrame: Dataframe containing test summary values for each specimen. \"\"\" fp = Path ( self . folder ) . resolve () rows = [ self . _extract_values ( df ) for df in [ self . _load ( f ) for f in sorted ( fp . rglob ( \"*.csv\" ))] ] # .T transposes to that it's the expected dataframe format return ( pd . concat ( rows , axis = 1 , ignore_index = True ) . T ) . convert_dtypes ()","title":"Static Test"},{"location":"api/static.html#any-static-test-class","text":"","title":"Any Static Test Class"},{"location":"api/static.html#pymechtest.base.BaseMechanicalTest","text":"Mechanical Test Base class. Parameters: Name Type Description Default folder Union[Path, str] String or Path-like folder containing test data. required id_row int Row number of the specimen ID. Most test machines export a headed csv file with some metadata like date, test method name etc, specimen ID should be contained in this section. Defaults to 0. required stress_col str Name of the column containing stress data. If not passed, pymechtest will try to autodetect it from your data. required strain_col str Name of the column containing strain data. If not passed, pymechtest will try to autodetect it from your data. required header int 0-indexed row number of the table header (i.e. the row containing things like \"Stress\", \"Strain\", \"Load\" etc.). Defaults to 0. required strain1 float Lower strain bound for modulus calculation. Must be in %. Defaults to 0.05. required strain2 float Upper strain bound for modulus calculation. Must be in %. Defaults to 0.15. required expect_yield bool Whether the specimens are expected to be elastic to failure (False) or they are expected to have a yield strength (True). Defaults to True. required","title":"pymechtest.base.BaseMechanicalTest"},{"location":"api/static.html#pymechtest.base.BaseMechanicalTest.load_all","text":"Loads all the found files in 'folder' into a dataframe. Recursively searches 'folder' for all csv files, grabs the specimen identifier specified during 'id_row' and includes this in the dataframe. Returns: Type Description DataFrame pd.DataFrame: All found test data with specimen identifier. Source code in pymechtest/base.py def load_all ( self ) -> pd . DataFrame : \"\"\" Loads all the found files in 'folder' into a dataframe. Recursively searches 'folder' for all csv files, grabs the specimen identifier specified during 'id_row' and includes this in the dataframe. Returns: pd.DataFrame: All found test data with specimen identifier. \"\"\" # Cast to Path so can glob even if user passed str fp = Path ( self . folder ) . resolve () df = ( ( pd . concat ([ self . _load ( f ) for f in sorted ( fp . rglob ( \"*.csv\" ))])) . assign ( spec_id = lambda x : pd . Categorical ( x [ \"Specimen ID\" ])) . drop ( columns = [ \"Specimen ID\" ]) . rename ( columns = { \"spec_id\" : \"Specimen ID\" }) ) # Reorder the columns for OCD reasons col = df . pop ( \"Specimen ID\" ) df . insert ( 0 , \"Specimen ID\" , col ) return df","title":"load_all()"},{"location":"api/static.html#pymechtest.base.BaseMechanicalTest.plot_curves","text":"Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Parameters: Name Type Description Default title Optional[str] Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". None save_path Union[str, pathlib.Path] str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. None save_method Optional[str] One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' 'selenium' x_label Optional[str] Label for x-axis. Defaults to \"{class name}Strain (%)\". None y_label Optional[str] Label for y-axis. Defaults to \"{class name}Stress (MPa)\". None height int Height of the plot. Defaults to 500. 500 width int Width of the plot. Defaults to 750. 750 Returns: Type Description Chart alt.Chart: Stress strain plot. Source code in pymechtest/base.py def plot_curves ( self , title : Optional [ str ] = None , save_path : Optional [ Union [ str , Path ]] = None , save_method : Optional [ str ] = \"selenium\" , x_label : Optional [ str ] = None , y_label : Optional [ str ] = None , height : int = 500 , width : int = 750 , ) -> alt . Chart : \"\"\" Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Args: title (str, optional): Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". save_path (Union[str, Path], optional): str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. save_method (str, optional): One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' x_label (str, optional): Label for x-axis. Defaults to \"{class name}Strain (%)\". y_label (str, optional): Label for y-axis. Defaults to \"{class name}Stress (MPa)\". height (int, optional): Height of the plot. Defaults to 500. width (int, optional): Width of the plot. Defaults to 750. Returns: alt.Chart: Stress strain plot. \"\"\" # Altair will warn if over 5,000 rows in a notebook. This is cleanest solution. alt . data_transformers . enable ( \"data_server\" ) if not x_label : x_label = f \" { self . __class__ . __qualname__ } Strain (%)\" if not y_label : y_label = f \" { self . __class__ . __qualname__ } Stress (MPa)\" if not title : title = f \" { self . __class__ . __qualname__ } Stress Strain Curves\" df = self . load_all () stress_col = self . _get_stress_col ( df ) strain_col = self . _get_strain_col ( df ) chart = ( alt . Chart ( data = df ) . mark_line ( size = 1 ) . encode ( x = alt . X ( f \" { strain_col } :Q\" , title = x_label ), y = alt . Y ( f \" { stress_col } :Q\" , title = y_label ), color = alt . Color ( \"Specimen ID:N\" , title = \"Specimen ID\" ), ) . properties ( title = title , height = height , width = width ) ) if save_method not in set ([ \"selenium\" , \"node\" ]): raise ValueError ( f \"Save method must be one of 'selenium' or 'node'. Got: { save_method } \" ) if save_path : fp = Path ( save_path ) . resolve () save ( chart , fp = str ( fp ), fmt = \"png\" , scale_factor = 6.0 , method = save_method , ) return chart","title":"plot_curves()"},{"location":"api/static.html#pymechtest.base.BaseMechanicalTest.stats","text":"Returns a table of summary statistics e.g. mean, std, cov etc. for the data in folder. Uses pandas df.describe() to do the bulk of the work, just adds in cov for good measure. Returns: Type Description DataFrame pd.DataFrame: Summary statistics. Source code in pymechtest/base.py def stats ( self ) -> pd . DataFrame : \"\"\" Returns a table of summary statistics e.g. mean, std, cov etc. for the data in folder. Uses pandas df.describe() to do the bulk of the work, just adds in cov for good measure. Returns: pd.DataFrame: Summary statistics. \"\"\" df = self . summarise () . describe () df . loc [ \"cov%\" ] = df . loc [ \"std\" ] / df . loc [ \"mean\" ] * 100 # Reorganise so cov is close to std new_index = [ \"count\" , \"mean\" , \"std\" , \"cov%\" , \"min\" , \"25%\" , \"50%\" , \"75%\" , \"max\" ] df = df . reindex ( new_index ) return df","title":"stats()"},{"location":"api/static.html#pymechtest.base.BaseMechanicalTest.summarise","text":"High level summary method, generates a dataframe containing key test values such as UTS, Modulus etc. for all the data in the target folder. Returns: Type Description DataFrame pd.DataFrame: Dataframe containing test summary values for each specimen. Source code in pymechtest/base.py def summarise ( self ) -> pd . DataFrame : \"\"\" High level summary method, generates a dataframe containing key test values such as UTS, Modulus etc. for all the data in the target folder. Returns: pd.DataFrame: Dataframe containing test summary values for each specimen. \"\"\" fp = Path ( self . folder ) . resolve () rows = [ self . _extract_values ( df ) for df in [ self . _load ( f ) for f in sorted ( fp . rglob ( \"*.csv\" ))] ] # .T transposes to that it's the expected dataframe format return ( pd . concat ( rows , axis = 1 , ignore_index = True ) . T ) . convert_dtypes ()","title":"summarise()"},{"location":"contributing/guide.html","text":"Contributing to pymechtest \u00b6 I've tried to structure pymechtest to make it nice and easy for people to contribute. Here's how to go about doing it! First, see the help section for some general info on how you can help pymechtest. Developing \u00b6 If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to pymechtest: here's how you do it! To work on pymechtest you'll need python >=3.7 Step 1: Fork pymechtest \u00b6 The first thing to do is 'fork' pymechtest. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of pymechtest still works! To create a fork, go to the pymechtest repo and click on the fork button! Step 2: Clone your fork \u00b6 Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/pymechtest.git If you use SSH: git clone git@github.com:<your_github_username>/pymechtest.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/pymechtest HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd pymechtest This will take you into the root directory of the project. Now add the original pymechtest repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/pymechtest.git This makes the original version of pymechtest 'upstream' but not 'origin'. Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower! Step 3: Create the Environment \u00b6 Before you do anything, you'll want to set up your virtual environment... python3 -m venv .venv This creates a virtual environment (called .venv) Now, activate your environment... # macOS and Linux source .venv/bin/activate # Windows . \\. venv. \\S cripts. \\A ctivate.ps1 To check it worked, use: # macOS and Linux which pip # Windows Get-Command pip It should say... some/directory/pymechtest/.venv/bin/pip If it shows this, it's worked! Step 4: Install the Dependencies \u00b6 Now you need to install pymechtest locally including all it's dependencies. That's as easy as: pip install . [ dev ] # If you use zsh, you may have to escape the square brackets pip install . \\[ dev \\] Side note: If you're on mac (uses zsh by default) and you have to escape the square brackets. Try setting this in your ~/.zshrc : # in ~/.zshrc # Means you don't have to escape square brackets unsetopt nomatch I mention that here because it took me AGES to find that! Step 5: Do your thing \u00b6 Always checkout a new branch before changing anything git checkout -b <name-of-your-bugfix-or-feature> So if I was going to fix a bug with the yield strength calculation I would do something like: git checkout -b yield-strength-bugfix Now you're ready to start working! Remember! pymechtest aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! pymechtest uses nox for automated testing, building the docs, formatting and linting etc. So when you've made your changes, just run: nox And it will tell you if something's wrong! Step 6: Commit your changes \u00b6 Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name> Step 7: Create a Pull Request \u00b6 Now go to the original pymechtest repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. Thats it! Your code will be tested automatically by pymechtest's CI suite and if everything passes and your PR is approved and merged then it will become part of pymechtest! Note: There is a good guide to open source contribution workflow here and also here too Contributing to Docs \u00b6 Any improvements to the documentation are always appreciated! pymechtest uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Because pymechtest uses nox , things like building and serving the documentation is super easy. All you have to do is: # Builds the docs nox -s docs # Builds and serves to localhost nox -s docs -- serve If you installed with .[dev] earlier, you could also just run mkdocs build --clean and mkdocs serve if you wanted If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"How to"},{"location":"contributing/guide.html#contributing-to-pymechtest","text":"I've tried to structure pymechtest to make it nice and easy for people to contribute. Here's how to go about doing it! First, see the help section for some general info on how you can help pymechtest.","title":"Contributing to pymechtest"},{"location":"contributing/guide.html#developing","text":"If you want to fix a bug, improve the docs, add tests, add a feature or any other type of direct contribution to pymechtest: here's how you do it! To work on pymechtest you'll need python >=3.7","title":"Developing"},{"location":"contributing/guide.html#step-1-fork-pymechtest","text":"The first thing to do is 'fork' pymechtest. This will put a version of it on your GitHub page. This means you can change that fork all you want and the actual version of pymechtest still works! To create a fork, go to the pymechtest repo and click on the fork button!","title":"Step 1: Fork pymechtest"},{"location":"contributing/guide.html#step-2-clone-your-fork","text":"Navigate to where you do your development work on your machine and open a terminal If you use HTTPS: git clone https://github.com/<your_github_username>/pymechtest.git If you use SSH: git clone git@github.com:<your_github_username>/pymechtest.git Or you can be really fancy and use the GH CLI gh repo clone <your_github_username>/pymechtest HTTPS is probably the one most people use! Once you've cloned the project, cd into it... cd pymechtest This will take you into the root directory of the project. Now add the original pymechtest repo as an upstream in your forked project: git remote add upstream https://github.com/FollowTheProcess/pymechtest.git This makes the original version of pymechtest 'upstream' but not 'origin'. Basically, this means that if your working on it for a while and the original project has changed in the meantime, you can do: git checkout main git fetch upstream git merge upstream/main git push origin main This will (in order): Checkout the main branch of your locally cloned fork Fetch any changes from the original project that have happened since you forked it Merge those changes in with what you have Push those changes up to your fork so your fork stays up to date with the original. Good practice is to do this before you start doing anything every time you start work, then the chances of you getting conflicting commits later on is much lower!","title":"Step 2: Clone your fork"},{"location":"contributing/guide.html#step-3-create-the-environment","text":"Before you do anything, you'll want to set up your virtual environment... python3 -m venv .venv This creates a virtual environment (called .venv) Now, activate your environment... # macOS and Linux source .venv/bin/activate # Windows . \\. venv. \\S cripts. \\A ctivate.ps1 To check it worked, use: # macOS and Linux which pip # Windows Get-Command pip It should say... some/directory/pymechtest/.venv/bin/pip If it shows this, it's worked!","title":"Step 3: Create the Environment"},{"location":"contributing/guide.html#step-4-install-the-dependencies","text":"Now you need to install pymechtest locally including all it's dependencies. That's as easy as: pip install . [ dev ] # If you use zsh, you may have to escape the square brackets pip install . \\[ dev \\] Side note: If you're on mac (uses zsh by default) and you have to escape the square brackets. Try setting this in your ~/.zshrc : # in ~/.zshrc # Means you don't have to escape square brackets unsetopt nomatch I mention that here because it took me AGES to find that!","title":"Step 4: Install the Dependencies"},{"location":"contributing/guide.html#step-5-do-your-thing","text":"Always checkout a new branch before changing anything git checkout -b <name-of-your-bugfix-or-feature> So if I was going to fix a bug with the yield strength calculation I would do something like: git checkout -b yield-strength-bugfix Now you're ready to start working! Remember! pymechtest aims for high test coverage. If you implement a new feature, make sure to write tests for it! Similarly, if you fix a bug, it's good practice to write a test that would have caught that bug so we can be sure it doesn't reappear in the future! pymechtest uses nox for automated testing, building the docs, formatting and linting etc. So when you've made your changes, just run: nox And it will tell you if something's wrong!","title":"Step 5: Do your thing"},{"location":"contributing/guide.html#step-6-commit-your-changes","text":"Once you're happy with what you've done, add the files you've changed: git add <changed-file ( s ) > # Might be easier to do git add -A # But be wary of this and check what it's added is what you wanted.. git status Commit your changes: git commit # Now write a good commit message explaining what you've done and why. While you were working on your changes, the original project might have changed (due to other people working on it). So first, you should rebase your current branch from the upstream destination. Doing this means that when you do your PR, it's all compatible: git pull --rebase upstream main Now push your changes to your fork: git push origin <your-branch-name>","title":"Step 6: Commit your changes"},{"location":"contributing/guide.html#step-7-create-a-pull-request","text":"Now go to the original pymechtest repo and create a Pull Request. Make sure to choose upstream repo \"main\" as the destination branch and your forked repo \"your-branch-name\" as the source. Thats it! Your code will be tested automatically by pymechtest's CI suite and if everything passes and your PR is approved and merged then it will become part of pymechtest! Note: There is a good guide to open source contribution workflow here and also here too","title":"Step 7: Create a Pull Request"},{"location":"contributing/guide.html#contributing-to-docs","text":"Any improvements to the documentation are always appreciated! pymechtest uses mkdocs with the mkdocs-material theme so the documentation is all written in markdown and can be found in the docs folder in the project root. Because pymechtest uses nox , things like building and serving the documentation is super easy. All you have to do is: # Builds the docs nox -s docs # Builds and serves to localhost nox -s docs -- serve If you installed with .[dev] earlier, you could also just run mkdocs build --clean and mkdocs serve if you wanted If you use the serve option, you can navigate to the localhost IP address it gives you and as you make changes to the source files, it will automatically reload your browser! Automation is power! If you add pages to the docs, make sure they are placed in the nav tree in the mkdocs.yml file and you're good to go!","title":"Contributing to Docs"},{"location":"contributing/help.html","text":"Help pymechtest \u00b6 If you use pymechtest and want to help, there are plenty of ways you can do that! Use it \u00b6 First and foremost, the biggest thing you can do to help pymechtest is to use it in your work and let me know if you run into a problem! If you think pymechtest should be able to do something that it currently can't: propose a new feature . If you've encountered a bug: raise an issue filing the bug report More Data \u00b6 I gathered some initial csv's to develop the project against when I first started and I've tried to make the API generalisable, but to truly make it into a general tool that works on all sorts of test data I need your data! The test csv files are found in tests/data . If you think you have a csv format that I haven't covered, create an issue or submit a PR to implement support for it. Create Issues \u00b6 You can create an issue to ask questions, suggest new features, file bug reports etc. Create a PR \u00b6 You can contribute to pymechtest by creating a PR , for example: Fix typos in the docs Fix a bug in the code Add new features Improve the testing and CI Anything else!","title":"Help"},{"location":"contributing/help.html#help-pymechtest","text":"If you use pymechtest and want to help, there are plenty of ways you can do that!","title":"Help pymechtest"},{"location":"contributing/help.html#use-it","text":"First and foremost, the biggest thing you can do to help pymechtest is to use it in your work and let me know if you run into a problem! If you think pymechtest should be able to do something that it currently can't: propose a new feature . If you've encountered a bug: raise an issue filing the bug report","title":"Use it"},{"location":"contributing/help.html#more-data","text":"I gathered some initial csv's to develop the project against when I first started and I've tried to make the API generalisable, but to truly make it into a general tool that works on all sorts of test data I need your data! The test csv files are found in tests/data . If you think you have a csv format that I haven't covered, create an issue or submit a PR to implement support for it.","title":"More Data"},{"location":"contributing/help.html#create-issues","text":"You can create an issue to ask questions, suggest new features, file bug reports etc.","title":"Create Issues"},{"location":"contributing/help.html#create-a-pr","text":"You can contribute to pymechtest by creating a PR , for example: Fix typos in the docs Fix a bug in the code Add new features Improve the testing and CI Anything else!","title":"Create a PR"},{"location":"getting_started/options.html","text":"Options & Arguments \u00b6 All the static test classes in pymechtest have the same options and arguments available to them. These help you tweak what it does and doesn't load, what format the columns are in, whether you have specimen ID numbers in the files etc. Here we'll explain how to use these with an example. Example \u00b6 Let's use the Tensile class for a simple batch of tensile tests. Don't forget, pymechtest also has Compression , Shear and Flexure classes we could easily have used, they all work exactly the same way! pymechtest is designed to work directly from the raw data exported by the machine, so all you have to do is 'point it' at the folder where your batch of test data is and it will do the rest. In order for it work properly though, with some formats of data you might have to configure a few things. ID Row \u00b6 Let's say you've just finished doing a batch of tensile tests and have a folder of randomly named csv files corresponding to this batch. Your csv file will look something like this (when opened in Excel): There may or may not be some metadata at the top of the file, and then there'll be your data below. In this example you notice we have a row called Specimen ID with the number 9, uniquely identifying this particular specimen in the batch. Well pymechtest can use this! All you have to do is specify which row this ID is on with the id_row argument... In our example, it's on the 4th row (so 3rd row in 0-indexed python) from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 ) Just by specifying this, you get this ID integrated into the rest of your work for free. For example, now the .summarise method will show it... If your csv structure doesn't have this format, don't worry. If you don't enter anything for id_row the Specimen ID column in the .summarise result will use the file name instead. Header \u00b6 Notice again in our example file, there's a load of metadata on top (which is where we got the Specimen ID from) containing things like specimen width, thickness etc. and the actual data doesn't start until later on down the file. If you just try and read this in as it is, you'll get an error... This error actually comes from pandas not from pymechtest, and it's because pandas tries to infer the structure of a csv from the first few rows. In our example case, the first few rows are different to the actual data. The actual data begins after row 9 (so 8 in 0-indexed python) To fix this, you need to pass the header argument, telling pymechtest which row the table header row is i.e. the row containing your column titles like Tensile stress etc. In our case, this means header = 8 from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 ) And now it works perfectly! Note: In our example, the csv file had the units in brackets below the table headers. If this is true for your data too, or infact if your data has any non-numerics below your table headers, don't worry! pymechtest (well actually pandas ) is smart enough to remove these for you. Currently pymechtest doesn't support unit conversion. It assumes SI units: Stress = MPa, Modulus = GPa, Strain = %. This is something I want to support in the future and is on the roadmap. Strain1 & Strain2 \u00b6 Notice that the .summarise method calculates the elastic modulus. But you didn't tell it to do that, and you didn't specify how to calculate it or what strain range to use etc. This is because pymechtest uses sensible defaults and actually configured this behind the scenes without you knowing. The range over which the elastic modulus is calculated is controlled by the strain1 and strain2 arguments and defaults to 0.05 and 0.15 (in % strain). This is a good range for a lot of common materials. You can always override this by explicitly defining what you want strain1 and strain2 to be... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 , strain1 = 0.001 , strain2 = 0.1 ) Now pymechtest will use your values of strain1 and strain2 to calculate the modulus. \\[ E=\\Delta\\sigma / \\Delta\\epsilon \\] With your ranges: \\[ E=\\Delta\\sigma / (strain2 - strain1) \\] Obviously, if you define your own ranges, it's now up to you that those ranges are valid and you are still capturing the elastic portion of the stress strain curve, so you might want to check it out with .plot_curves() first! Currently, only Young's modulus is supported. In the future I want to provide the option for different types of modulus i.e. secant, chord etc. This is on the roadmap! Expect Yield \u00b6 You've seen how the .summarise method returns a column for yield strength in our earlier example. How did it know how to do that? Well there's an argument for that: expect_yield which defaults to True (a sensible default). If you were testing a load of carbon fibre test pieces in the fibre direction, they are elastic to failure and the concept of yield strength becomes irrelevant. In that case, you would pass expect_yield = False when instantiating the Tensile class... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 , header = 8 , expect_yield = False ) Now if you call .summarise on your non-yielding data, you won't see the yield strength column because it won't be calculated... By tweaking all these things, it's my aim that pymechtest can be used to help you process lots of different types of mechanical test data output!","title":"Options"},{"location":"getting_started/options.html#options-arguments","text":"All the static test classes in pymechtest have the same options and arguments available to them. These help you tweak what it does and doesn't load, what format the columns are in, whether you have specimen ID numbers in the files etc. Here we'll explain how to use these with an example.","title":"Options &amp; Arguments"},{"location":"getting_started/options.html#example","text":"Let's use the Tensile class for a simple batch of tensile tests. Don't forget, pymechtest also has Compression , Shear and Flexure classes we could easily have used, they all work exactly the same way! pymechtest is designed to work directly from the raw data exported by the machine, so all you have to do is 'point it' at the folder where your batch of test data is and it will do the rest. In order for it work properly though, with some formats of data you might have to configure a few things.","title":"Example"},{"location":"getting_started/options.html#id-row","text":"Let's say you've just finished doing a batch of tensile tests and have a folder of randomly named csv files corresponding to this batch. Your csv file will look something like this (when opened in Excel): There may or may not be some metadata at the top of the file, and then there'll be your data below. In this example you notice we have a row called Specimen ID with the number 9, uniquely identifying this particular specimen in the batch. Well pymechtest can use this! All you have to do is specify which row this ID is on with the id_row argument... In our example, it's on the 4th row (so 3rd row in 0-indexed python) from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 ) Just by specifying this, you get this ID integrated into the rest of your work for free. For example, now the .summarise method will show it... If your csv structure doesn't have this format, don't worry. If you don't enter anything for id_row the Specimen ID column in the .summarise result will use the file name instead.","title":"ID Row"},{"location":"getting_started/options.html#header","text":"Notice again in our example file, there's a load of metadata on top (which is where we got the Specimen ID from) containing things like specimen width, thickness etc. and the actual data doesn't start until later on down the file. If you just try and read this in as it is, you'll get an error... This error actually comes from pandas not from pymechtest, and it's because pandas tries to infer the structure of a csv from the first few rows. In our example case, the first few rows are different to the actual data. The actual data begins after row 9 (so 8 in 0-indexed python) To fix this, you need to pass the header argument, telling pymechtest which row the table header row is i.e. the row containing your column titles like Tensile stress etc. In our case, this means header = 8 from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 ) And now it works perfectly! Note: In our example, the csv file had the units in brackets below the table headers. If this is true for your data too, or infact if your data has any non-numerics below your table headers, don't worry! pymechtest (well actually pandas ) is smart enough to remove these for you. Currently pymechtest doesn't support unit conversion. It assumes SI units: Stress = MPa, Modulus = GPa, Strain = %. This is something I want to support in the future and is on the roadmap.","title":"Header"},{"location":"getting_started/options.html#strain1-strain2","text":"Notice that the .summarise method calculates the elastic modulus. But you didn't tell it to do that, and you didn't specify how to calculate it or what strain range to use etc. This is because pymechtest uses sensible defaults and actually configured this behind the scenes without you knowing. The range over which the elastic modulus is calculated is controlled by the strain1 and strain2 arguments and defaults to 0.05 and 0.15 (in % strain). This is a good range for a lot of common materials. You can always override this by explicitly defining what you want strain1 and strain2 to be... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" , id_row = 3 , header = 8 , strain1 = 0.001 , strain2 = 0.1 ) Now pymechtest will use your values of strain1 and strain2 to calculate the modulus. \\[ E=\\Delta\\sigma / \\Delta\\epsilon \\] With your ranges: \\[ E=\\Delta\\sigma / (strain2 - strain1) \\] Obviously, if you define your own ranges, it's now up to you that those ranges are valid and you are still capturing the elastic portion of the stress strain curve, so you might want to check it out with .plot_curves() first! Currently, only Young's modulus is supported. In the future I want to provide the option for different types of modulus i.e. secant, chord etc. This is on the roadmap!","title":"Strain1 &amp; Strain2"},{"location":"getting_started/options.html#expect-yield","text":"You've seen how the .summarise method returns a column for yield strength in our earlier example. How did it know how to do that? Well there's an argument for that: expect_yield which defaults to True (a sensible default). If you were testing a load of carbon fibre test pieces in the fibre direction, they are elastic to failure and the concept of yield strength becomes irrelevant. In that case, you would pass expect_yield = False when instantiating the Tensile class... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" , id_row = 3 , header = 8 , expect_yield = False ) Now if you call .summarise on your non-yielding data, you won't see the yield strength column because it won't be calculated... By tweaking all these things, it's my aim that pymechtest can be used to help you process lots of different types of mechanical test data output!","title":"Expect Yield"},{"location":"getting_started/plot.html","text":"Plot Curves \u00b6 Probably the most important thing to do when analysing mechanical test data is to plot stress-strain curves for the batch so you can compare. pymechtest uses altair makes it super easy to plot really nice looking stress-strain curves by default. The pymechtest plot style is very opinionated, the plots will come out looking the same every time and the API exposes very little in the way of customisation. If you want full control over how you want the plots to look, you might want to just do it manually by loading the data in with .load_all() and then using whatever plotting tool you like. Every static test method currently supported in pymechtest has a .plot_curves() method. Lets take a look at it... plot_curves \u00b6 \u00b6 Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Parameters: Name Type Description Default title Optional[str] Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". None save_path Union[str, pathlib.Path] str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. None save_method Optional[str] One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' 'selenium' x_label Optional[str] Label for x-axis. Defaults to \"{class name}Strain (%)\". None y_label Optional[str] Label for y-axis. Defaults to \"{class name}Stress (MPa)\". None height int Height of the plot. Defaults to 500. 500 width int Width of the plot. Defaults to 750. 750 Returns: Type Description Chart alt.Chart: Stress strain plot. Source code in pymechtest/base.py def plot_curves ( self , title : Optional [ str ] = None , save_path : Optional [ Union [ str , Path ]] = None , save_method : Optional [ str ] = \"selenium\" , x_label : Optional [ str ] = None , y_label : Optional [ str ] = None , height : int = 500 , width : int = 750 , ) -> alt . Chart : \"\"\" Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Args: title (str, optional): Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". save_path (Union[str, Path], optional): str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. save_method (str, optional): One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' x_label (str, optional): Label for x-axis. Defaults to \"{class name}Strain (%)\". y_label (str, optional): Label for y-axis. Defaults to \"{class name}Stress (MPa)\". height (int, optional): Height of the plot. Defaults to 500. width (int, optional): Width of the plot. Defaults to 750. Returns: alt.Chart: Stress strain plot. \"\"\" # Altair will warn if over 5,000 rows in a notebook. This is cleanest solution. alt . data_transformers . enable ( \"data_server\" ) if not x_label : x_label = f \" { self . __class__ . __qualname__ } Strain (%)\" if not y_label : y_label = f \" { self . __class__ . __qualname__ } Stress (MPa)\" if not title : title = f \" { self . __class__ . __qualname__ } Stress Strain Curves\" df = self . load_all () stress_col = self . _get_stress_col ( df ) strain_col = self . _get_strain_col ( df ) chart = ( alt . Chart ( data = df ) . mark_line ( size = 1 ) . encode ( x = alt . X ( f \" { strain_col } :Q\" , title = x_label ), y = alt . Y ( f \" { stress_col } :Q\" , title = y_label ), color = alt . Color ( \"Specimen ID:N\" , title = \"Specimen ID\" ), ) . properties ( title = title , height = height , width = width ) ) if save_method not in set ([ \"selenium\" , \"node\" ]): raise ValueError ( f \"Save method must be one of 'selenium' or 'node'. Got: { save_method } \" ) if save_path : fp = Path ( save_path ) . resolve () save ( chart , fp = str ( fp ), fmt = \"png\" , scale_factor = 6.0 , method = save_method , ) return chart Making your plot \u00b6 In 90% of the cases, you will probably just need to call plot_curves() with no arguments. Again, following the principle of sensible defaults , pymechtest will fill out a lot of the information for you. For instance, if you're calling plot_curves() from an instance of the Tensile class, the title will be \"Tensile Stress Strain Curves\" and the axes titles will be \"Tensile Stress\" and \"Tensile Strain\".","title":"Plot Curves"},{"location":"getting_started/plot.html#plot-curves","text":"Probably the most important thing to do when analysing mechanical test data is to plot stress-strain curves for the batch so you can compare. pymechtest uses altair makes it super easy to plot really nice looking stress-strain curves by default. The pymechtest plot style is very opinionated, the plots will come out looking the same every time and the API exposes very little in the way of customisation. If you want full control over how you want the plots to look, you might want to just do it manually by loading the data in with .load_all() and then using whatever plotting tool you like. Every static test method currently supported in pymechtest has a .plot_curves() method. Lets take a look at it...","title":"Plot Curves"},{"location":"getting_started/plot.html#plot_curves","text":"","title":"plot_curves"},{"location":"getting_started/plot.html#pymechtest.base.BaseMechanicalTest.plot_curves","text":"Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Parameters: Name Type Description Default title Optional[str] Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". None save_path Union[str, pathlib.Path] str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. None save_method Optional[str] One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' 'selenium' x_label Optional[str] Label for x-axis. Defaults to \"{class name}Strain (%)\". None y_label Optional[str] Label for y-axis. Defaults to \"{class name}Stress (MPa)\". None height int Height of the plot. Defaults to 500. 500 width int Width of the plot. Defaults to 750. 750 Returns: Type Description Chart alt.Chart: Stress strain plot. Source code in pymechtest/base.py def plot_curves ( self , title : Optional [ str ] = None , save_path : Optional [ Union [ str , Path ]] = None , save_method : Optional [ str ] = \"selenium\" , x_label : Optional [ str ] = None , y_label : Optional [ str ] = None , height : int = 500 , width : int = 750 , ) -> alt . Chart : \"\"\" Creates a nice looking stress strain plot of all the specimens using altair. Will use the class name to fill in axis labels if not passed, e.g 'Tensile' Strain Args: title (str, optional): Title for the plot. Defaults to \"{class_name} Stress-Strain Curves\". save_path (Union[str, Path], optional): str or Pathlike path to save a png of the plot. Requires chrome and selenium. If not passed, plot is simply returned and not saved. save_method (str, optional): One of 2 altair save methods: 'selenium' or 'node'. if 'selenium' requires a configured geckodriver or chromedriver on PATH. if 'node' requires nodejs installation. Defaults to 'selenium' x_label (str, optional): Label for x-axis. Defaults to \"{class name}Strain (%)\". y_label (str, optional): Label for y-axis. Defaults to \"{class name}Stress (MPa)\". height (int, optional): Height of the plot. Defaults to 500. width (int, optional): Width of the plot. Defaults to 750. Returns: alt.Chart: Stress strain plot. \"\"\" # Altair will warn if over 5,000 rows in a notebook. This is cleanest solution. alt . data_transformers . enable ( \"data_server\" ) if not x_label : x_label = f \" { self . __class__ . __qualname__ } Strain (%)\" if not y_label : y_label = f \" { self . __class__ . __qualname__ } Stress (MPa)\" if not title : title = f \" { self . __class__ . __qualname__ } Stress Strain Curves\" df = self . load_all () stress_col = self . _get_stress_col ( df ) strain_col = self . _get_strain_col ( df ) chart = ( alt . Chart ( data = df ) . mark_line ( size = 1 ) . encode ( x = alt . X ( f \" { strain_col } :Q\" , title = x_label ), y = alt . Y ( f \" { stress_col } :Q\" , title = y_label ), color = alt . Color ( \"Specimen ID:N\" , title = \"Specimen ID\" ), ) . properties ( title = title , height = height , width = width ) ) if save_method not in set ([ \"selenium\" , \"node\" ]): raise ValueError ( f \"Save method must be one of 'selenium' or 'node'. Got: { save_method } \" ) if save_path : fp = Path ( save_path ) . resolve () save ( chart , fp = str ( fp ), fmt = \"png\" , scale_factor = 6.0 , method = save_method , ) return chart","title":"pymechtest.base.BaseMechanicalTest.plot_curves"},{"location":"getting_started/plot.html#making-your-plot","text":"In 90% of the cases, you will probably just need to call plot_curves() with no arguments. Again, following the principle of sensible defaults , pymechtest will fill out a lot of the information for you. For instance, if you're calling plot_curves() from an instance of the Tensile class, the title will be \"Tensile Stress Strain Curves\" and the axes titles will be \"Tensile Stress\" and \"Tensile Strain\".","title":"Making your plot"},{"location":"getting_started/usage.html","text":"Usage \u00b6 pymechtest is a super tiny package, it focusses on just a few common tasks, as such it's super easy to learn! Installation \u00b6 The very first thing you need to do is install pymechtest : pip install pymechtest This will install pymechtest and its core dependencies. Getting Data In \u00b6 All you have to do to get data into pymechtest is instantiate the class specific to your test method (pymechtest currently supports Tensile , Flexure , and Compression static tests with some limited support for Fatigue (I'm working on it!))... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) This path can either be a simple string as in the example above, or you can pass it a pathlib.Path or infact any osPathLike object... from pymechtest import Tensile from pathlib import Path data = Path ( \"path/to/raw/data\" ) . resolve () tens = Tensile ( folder = data ) Under the hood, pymechtest converts this to a pathlib.Path anyway so it can easily glob pattern match for csv files. Now What? \u00b6 Now you have your data in, you can do a few things with it. Load to a Dataframe \u00b6 If you know pandas and want to use its comprehensive functionality to manipulate your data, you can get your entire folder of data in a single dataframe... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) df = tens . load_all () This will recursively search your folder for csv files and load them all into a dataframe for you to do whatever you want with! Summarise \u00b6 If all you really want to see are the key values like elastic modulus, tensile strength etc for each specimen in your sample, use the .summarise() method... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . summarise () This will extract key values such as elastic modulus, tensile strength, yield strength (if expect_yield = True we'll talk about this later.) for each specimen in your sample. Stress-Strain Curves \u00b6 Making nice looking stress strain curves has always been the bane of my life. With pymechtest, a gorgeous graph is only a method away.. from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . plot_curves () If you're working in a jupyter notebook or an IDE that supports them you will see the plot appear. You can also save the generated plot but we'll talk about that later too.","title":"Usage"},{"location":"getting_started/usage.html#usage","text":"pymechtest is a super tiny package, it focusses on just a few common tasks, as such it's super easy to learn!","title":"Usage"},{"location":"getting_started/usage.html#installation","text":"The very first thing you need to do is install pymechtest : pip install pymechtest This will install pymechtest and its core dependencies.","title":"Installation"},{"location":"getting_started/usage.html#getting-data-in","text":"All you have to do to get data into pymechtest is instantiate the class specific to your test method (pymechtest currently supports Tensile , Flexure , and Compression static tests with some limited support for Fatigue (I'm working on it!))... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) This path can either be a simple string as in the example above, or you can pass it a pathlib.Path or infact any osPathLike object... from pymechtest import Tensile from pathlib import Path data = Path ( \"path/to/raw/data\" ) . resolve () tens = Tensile ( folder = data ) Under the hood, pymechtest converts this to a pathlib.Path anyway so it can easily glob pattern match for csv files.","title":"Getting Data In"},{"location":"getting_started/usage.html#now-what","text":"Now you have your data in, you can do a few things with it.","title":"Now What?"},{"location":"getting_started/usage.html#load-to-a-dataframe","text":"If you know pandas and want to use its comprehensive functionality to manipulate your data, you can get your entire folder of data in a single dataframe... from pymechtest import Tensile tens = Tensile ( folder = \"path/to/raw/data\" ) df = tens . load_all () This will recursively search your folder for csv files and load them all into a dataframe for you to do whatever you want with!","title":"Load to a Dataframe"},{"location":"getting_started/usage.html#summarise","text":"If all you really want to see are the key values like elastic modulus, tensile strength etc for each specimen in your sample, use the .summarise() method... from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . summarise () This will extract key values such as elastic modulus, tensile strength, yield strength (if expect_yield = True we'll talk about this later.) for each specimen in your sample.","title":"Summarise"},{"location":"getting_started/usage.html#stress-strain-curves","text":"Making nice looking stress strain curves has always been the bane of my life. With pymechtest, a gorgeous graph is only a method away.. from pymechtest import Tensile tens = Tensile ( \"path/to/raw/data\" ) tens . plot_curves () If you're working in a jupyter notebook or an IDE that supports them you will see the plot appear. You can also save the generated plot but we'll talk about that later too.","title":"Stress-Strain Curves"}]}